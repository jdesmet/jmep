import com.googlecode.jmep.Environment;import com.googlecode.jmep.Expression;import com.googlecode.jmep.BasicEnvironment;import com.googlecode.jmep.ExpressionException;import static org.junit.Assert.*;import java.math.BigDecimal;//import org.junit.After;//import org.junit.AfterClass;//import org.junit.BeforeClass;import org.junit.Before;import org.junit.Test;public class TestJMEP {  private Environment env;  @Before public void initializeEnvironment() {    env = BasicEnvironment.getInstance();    /* add a unit called 'mm' to the environment */    env.registerUnit("mm", Double.class, (t)->0.001*t);    env.registerUnit("mm", Long.class, (t)->0.001*t);    /* add a function called 'sin' to the environment */    env.addFunction("sin", (Object [] oPars) -> {          if (oPars == null || oPars.length != 1) throw new IllegalArgumentException("Expect at least one parameter");          if (oPars[0] instanceof Number)            return Math.sin(((Number)oPars[0]).doubleValue());          throw new IllegalArgumentException("Was not getting the expected type of parameters: "+oPars[0].getClass().getName());    });    env.addConstant("e",2.71);    env.addConstant("pi",3.14);    env.addConstant("name","neemsoft");    env.addConstant("one", 1);    env.addVariable("x", () -> x);    env.addVariable("y", () -> y);    env.addVariable("z", () -> z);    env.addVariable("p", () -> p);    env.addVariable("m", () -> m);    env.addVariable("a", () -> a);    env.addVariable("b", () -> b);  }  int x=0;  int y=0;  int z=0;  int p=0;  int m=0;  int a=0;  int b=0;    @Test public void simpleExpression() throws ExpressionException {      Object result;      result = (new Expression("one*2+3*4+(1+2*3)+1",env)).evaluate();      assertEquals(22L,result);  }    @Test public void variousExpressions() throws ExpressionException {      Object result;            result = (new Expression("1*2+3*4+(1+2*3)+1",env)).evaluate();      assertEquals(22L,result);      result = (new Expression("1+4*3^2+1",env)).evaluate();      assertEquals(38L,result);      result = (new Expression("1 <> 2",env)).evaluate();      assertEquals(1L,result);            x=2; y=-3;      result = (new Expression("x^2+y^3",env)).evaluate();      assertEquals(-23L,result);      p=1; m=-4; z=-2;      result = (new Expression("p*m^2-z^3",env)).evaluate();      assertEquals(24L,result);      // Typical for Programming Languages, Unary always takes precedence      // Over Binary Operators. So below formula's, although looking similar,      // will give different results. Use Parentheses to remove confusion.      result = (new Expression("-2^2",env)).evaluate();      assertEquals(4L,result);      result = (new Expression("(-2)^2",env)).evaluate();      assertEquals(4L,result);      result = (new Expression("-(2^2)",env)).evaluate();      assertEquals(-4L,result);      result = (new Expression("0-2^2",env)).evaluate();      assertEquals(-4L,result);      x=-3; y=-2;      result = (new Expression("-x^2-y^3",env)).evaluate();      assertEquals(17L,result);            result = (new Expression("0-x^2-y^3",env)).evaluate();      assertEquals(-1L,result);      a=-2; b=3;      result = (new Expression("a^2-b^2*a",env)).evaluate();      assertEquals(22L,result);      result = (new Expression("0.01*100-1")).evaluate();      assertEquals(0.0,result);  }  @Test public void divide() throws ExpressionException {    Object result;    result = (new Expression("1/0",env)).evaluate();    assertEquals(Double.POSITIVE_INFINITY, result);    result = (new Expression("-1/0",env)).evaluate();    assertEquals(Double.NEGATIVE_INFINITY, result);    result = (new Expression("0/0",env)).evaluate();    assertEquals(Double.NaN, result);    result = (new Expression("1/2",env)).evaluate();    assertEquals(0.5, result);    result = (new Expression("4/2",env)).evaluate();    assertEquals(2L, result);    result = (new Expression("1.2/2",env)).evaluate();    assertEquals(0.6, result);  }  @Test(expected=com.googlecode.jmep.ExpressionException.class) public void testArguments() throws ExpressionException {    try {      (new Expression("1&&0",env)).evaluate();    } catch (ExpressionException xx) {      assertEquals(xx.getMessage(), "ERROR(@1): AND on [?,?]: Wrong number of arguments");      throw xx;    }    assertTrue(false); // should never reach  }  @Test(expected=com.googlecode.jmep.UndefinedOperatorException.class) public void doubleOnEquality() throws ExpressionException {      Object result;      // Can not compare two double values on equality because of statistical improbability.      result = (new Expression("sin(12.0) = pi",env)).evaluate();      assertEquals(0,result);  }  @Test public void longExpression() throws ExpressionException {	  Object result;	        result = (new Expression("10000000000",env)).evaluate();      assertEquals(10000000000L,result);      result = (new Expression("4000000*10",env)).evaluate();      assertEquals(4000000L*10,result);      result = (new Expression("1000000000000000000000000000000",env)).evaluate();      assertEquals(new Double("1e30"),result);  }  @Test public void financialExpression() throws ExpressionException {	  Object result;      result = (new Expression("1000000000000000000000000000000",Environment.getInstance(Expression.OperationalMode.FINANCIAL))).evaluate();      assertEquals(new BigDecimal("1e30"),result);  }  }