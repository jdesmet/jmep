import com.googlecode.jmep.Environment;import com.googlecode.jmep.Expression;import com.googlecode.jmep.BasicEnvironment;import com.googlecode.jmep.ExpressionException;import static org.junit.Assert.*;import java.math.BigDecimal;//import org.junit.After;//import org.junit.AfterClass;//import org.junit.BeforeClass;import org.junit.Before;import org.junit.Test;public class TestJMEP {  private Environment env;  @Before public void initializeEnvironment() {    env = BasicEnvironment.getInstance();    /* add a unit called 'mm' to the environment */    env.registerUnit("mm", Double.class, (t)->0.001*t);    env.registerUnit("mm", Long.class, (t)->0.001*t);    env.addConstant("name","neemsoft");    env.addConstant("one", 1);    env.addFunction("one", (Object [] p)->1); // For Testing a No-Arg Func    env.addVariable("x", () -> x);    env.addVariable("y", () -> y);    env.addVariable("z", () -> z);    env.addVariable("p", () -> p);    env.addVariable("m", () -> m);    env.addVariable("a", () -> a);    env.addVariable("b", () -> b);  }  int x=0;  int y=0;  int z=0;  int p=0;  int m=0;  int a=0;  int b=0;    @Test public void simpleExpression() throws ExpressionException {      Object result;      result = (new Expression("one*2+3*4+(1+2*3)+1",env)).evaluate();      assertEquals(22L,result);  }    @Test public void variousExpressions() throws ExpressionException {      Object result;            result = (new Expression("1*2+3*4+(1+2*3)+1",env)).evaluate();      assertEquals(22L,result);      result = (new Expression("1+4*3^2+1",env)).evaluate();      assertEquals(38L,result);      result = (new Expression("1 <> 2",env)).evaluate();      assertEquals(1L,result);            x=2; y=-3;      result = (new Expression("x^2+y^3",env)).evaluate();      assertEquals(-23L,result);      p=1; m=-4; z=-2;      result = (new Expression("p*m^2-z^3",env)).evaluate();      assertEquals(24L,result);      // Typical for Programming Languages, Unary always takes precedence      // Over Binary Operators. So below formula's, although looking similar,      // will give different results. Use Parentheses to remove confusion.      result = (new Expression("-2^2",env)).evaluate();      assertEquals(4L,result);      result = (new Expression("(-2)^2",env)).evaluate();      assertEquals(4L,result);      result = (new Expression("-(2^2)",env)).evaluate();      assertEquals(-4L,result);      result = (new Expression("0-2^2",env)).evaluate();      assertEquals(-4L,result);      x=-3; y=-2;      result = (new Expression("-x^2-y^3",env)).evaluate();      assertEquals(17L,result);            result = (new Expression("0-x^2-y^3",env)).evaluate();      assertEquals(-1L,result);      a=-2; b=3;      result = (new Expression("a^2-b^2*a",env)).evaluate();      assertEquals(22L,result);      result = (new Expression("0.01*100-1")).evaluate();      assertEquals(0.0,result);            result = (new Expression("round(sin(30*pi/180)*1000)/1000")).evaluate();      assertEquals(0.5,result);        }  @Test public void zeroArgumentFunc() throws ExpressionException {      // Algorithm cannot differentiate no-pars from 1 par, as it is using      // a very basic counting algorithm, counting just comma and close paranthesis.      // Users should for now not use zero argument functions, and instead use      // variables which will have the same effect.      // Pretest is needed to find CPA following FNC immediately to handle case,      // or, need a completely new tokenizer that parses using a tree rather than      // using the shunting algorithm. A new tokenizer using a tree would also be      // able to find syntactical problems more correctly at compile time.      Object result = (new Expression("one()")).evaluate();      assertEquals(1L,result);  }    @Test public void divide() throws ExpressionException {    Object result;    result = (new Expression("1/0",env)).evaluate();    assertEquals(Double.POSITIVE_INFINITY, result);    result = (new Expression("-1/0",env)).evaluate();    assertEquals(Double.NEGATIVE_INFINITY, result);    result = (new Expression("0/0",env)).evaluate();    assertEquals(Double.NaN, result);    result = (new Expression("1/2",env)).evaluate();    assertEquals(0.5, result);    result = (new Expression("4/2",env)).evaluate();    assertEquals(2L, result);    result = (new Expression("1.2/2",env)).evaluate();    assertEquals(0.6, result);  }  @Test(expected=com.googlecode.jmep.ExpressionException.class) public void testArguments() throws ExpressionException {    try {      (new Expression("1&&0",env)).evaluate();    } catch (ExpressionException xx) {      assertEquals(xx.getMessage(), "ERROR(@1): AND on [?,?]: Wrong number of arguments");      throw xx;    }    assertTrue(false); // should never reach  }  @Test(expected=com.googlecode.jmep.UndefinedOperatorException.class) public void doubleOnEquality() throws ExpressionException {      Object result;      // Can not compare two double values on equality because of statistical improbability.      result = (new Expression("sin(12.0) = pi",env)).evaluate();      assertEquals(0,result);  }  @Test public void longExpression() throws ExpressionException {	  Object result;	        result = (new Expression("10000000000",env)).evaluate();      assertEquals(10000000000L,result);      result = (new Expression("4000000*10",env)).evaluate();      assertEquals(4000000L*10,result);      result = (new Expression("1000000000000000000000000000000",env)).evaluate();      assertEquals(new Double("1e30"),result);  }  @Test public void financialExpression() throws ExpressionException {	  Object result;      result = (new Expression("1000000000000000000000000000000",Environment.getInstance(Expression.OperationalMode.FINANCIAL))).evaluate();      assertEquals(new BigDecimal("1e30"),result);  }  }