/* * JMEP - Java Mathematical Expression Parser. * Copyright (C) 1999  Jo Desmet *  * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or any later version. *  * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. *  * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA *  * You can contact the Original submitter of this library by * email at: Jo_Desmet@yahoo.com. *  */package com.iabcinc.jmep.tokens;import com.iabcinc.jmep.XExpression;import com.iabcinc.jmep.XIllegalOperation;import com.iabcinc.jmep.XIllegalStatus;public class BINToken extends Token {  public enum Operator {    POW  (9,false), /* Raise to a power */    MUL  (8,true ), /* Multiply */    DIV  (8,false), /* divide (non-strict: int/int=double) */    MOD  (8,false), /* Modulus for a division */    ADD  (7,true ), /* Add */    SUB  (7,false), /* Subtract */    LT   (6,false), /* Test for Less Than */    GT   (6,false), /* Test for More Than */    LE   (6,false), /* Test for Less or Equal */    GE   (6,false), /* Test for More or Equal */    NE   (6,true ), /* Test for non-Equality */    EQ   (6,true ), /* Test for Equality */    AND  (4,true ), /* Bitwise AND */    OR   (2,true ), /* Bitwise OR */    XOR  (3,true ), /* Bitwise XOR */    LAND (1,true ), /* Logical AND */    LOR  (0,true ), /* Logical OR */    SDIV (8,false); /* Strict division (int/int = int) */    public final int precedence;    public final boolean commutative;    public boolean isCommutative() {      return commutative;    }        Operator(int precedence,boolean commutative) {      this.precedence = precedence;      this.commutative = commutative;    }  }    private Operator m_kBINToken;  //private int m_iPrecedence;  static int resolvePrecedence(Operator kBINToken) {    return kBINToken.precedence;  }  public BINToken(Operator kBINToken,int iPosition) {    super(Token.BIN,iPosition);    m_kBINToken = kBINToken;    //m_iPrecedence = resolvePrecedence(kBINToken);  }    public int getPrecedence() {    return m_kBINToken.precedence;  }  public Operator getKindOfBIN() {    return m_kBINToken;  }    public Object evaluate(Object oValue1, Object oValue2)  throws XExpression {    if (oValue1 instanceof Integer) {      int dValue1 = ((Integer)oValue1).intValue();      if (oValue2 instanceof Integer) {        int dValue2 = ((Integer)oValue2).intValue();        switch (m_kBINToken) {          case POW:            /*             * RESTRICTION: always returns double. Example: 2^2 will             * always give 4.0 as result and not 4 !!             */            return new Double(Math.pow(dValue1,dValue2));          case MUL:  return new Integer(dValue1*dValue2);          case SDIV: return new Integer(dValue1/dValue2);          case DIV:  return new Double((double)dValue1/dValue2);          case MOD:  return new Integer(dValue1%dValue2);          case ADD:  return new Integer(dValue1+dValue2);          case SUB:  return new Integer(dValue1-dValue2);          case LT:   return new Integer((dValue1 < dValue2)?1:0);          case GT:   return new Integer((dValue1 > dValue2)?1:0);          case LE:   return new Integer((dValue1 <= dValue2)?1:0);          case GE:   return new Integer((dValue1 >= dValue2)?1:0);          case NE:   return new Integer((dValue1 != dValue2)?1:0);          case EQ:   return new Integer((dValue1 == dValue2)?1:0);          case AND:  return new Integer(dValue1&dValue2);          case XOR:  return new Integer(dValue1^dValue2);          case OR:   return new Integer(dValue1|dValue2);          case LAND: return new Integer(((dValue1 != 0) && (dValue2 != 0))?1:0);          case LOR:  return new Integer(((dValue1 != 0) || (dValue2 != 0))?1:0);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (oValue2 instanceof Double) {        double fValue2 = ((Double)oValue2).doubleValue();        switch (m_kBINToken) {          case POW:  return new Double(Math.pow(dValue1,fValue2));          case MUL:  return new Double(dValue1*fValue2);          case SDIV: /* continue with next */          case DIV:  return new Double(dValue1/fValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return new Double(dValue1+fValue2);          case SUB:  return new Double(dValue1-fValue2);          case LT:   return new Integer((dValue1 < fValue2)?1:0);          case GT:   return new Integer((dValue1 > fValue2)?1:0);          case LE:   return new Integer((dValue1 <= fValue2)?1:0);          case GE:   return new Integer((dValue1 >= fValue2)?1:0);          /*           * REMARK: NE and EQ will be considered illegal operations here           * because of the statistical probability of meeting the condition.           */          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (oValue2 instanceof String) {        String sValue2 = (String)oValue2;        switch (m_kBINToken) {          case POW:  throw new XIllegalOperation(this,oValue1,oValue2);          case MUL: {            String sValue = sValue2;            if (dValue1 <= 0) throw new XIllegalOperation(this,oValue1,oValue2);            for (int iCount = 1; iCount < dValue1; iCount++) {              sValue = sValue + sValue2;            }            return sValue;          }          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,oValue1,oValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return Integer.toString(dValue1) + sValue2;          case SUB:  throw new XIllegalOperation(this,oValue1,oValue2);          case LT:   throw new XIllegalOperation(this,oValue1,oValue2);          case GT:   throw new XIllegalOperation(this,oValue1,oValue2);          case LE:   throw new XIllegalOperation(this,oValue1,oValue2);          case GE:   throw new XIllegalOperation(this,oValue1,oValue2);          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else        throw new XIllegalStatus(getPosition());    }    else if (oValue1 instanceof Double) {      double fValue1 = ((Double)oValue1).doubleValue();      if (oValue2 instanceof Integer) {        int dValue2 = ((Integer)oValue2).intValue();        /*         * REMARK: NE and EQ will be considered illegal operations here         * because of the statistical probability of meeting the condition.         */        switch (m_kBINToken) {          case POW:  return new Double(Math.pow(fValue1,dValue2));          case MUL:  return new Double(fValue1*dValue2);          case SDIV: /* continue with next */          case DIV:  return new Double(fValue1/dValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return new Double(fValue1+dValue2);          case SUB:  return new Double(fValue1-dValue2);          case LT:   return new Integer((fValue1 < dValue2)?1:0);          case GT:   return new Integer((fValue1 > dValue2)?1:0);          case LE:   return new Integer((fValue1 <= dValue2)?1:0);          case GE:   return new Integer((fValue1 >= dValue2)?1:0);          /*           * REMARK: NE and EQ will be considered illegal operations here           * because of the statistical probability of meeting the condition.           */          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (oValue2 instanceof Double) {        double fValue2 = ((Double)oValue2).doubleValue();        switch (m_kBINToken) {          case POW:  return new Double(Math.pow(fValue1,fValue2));          case MUL:  return new Double(fValue1*fValue2);          case SDIV: /* continue with next */          case DIV:  return new Double(fValue1/fValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return new Double(fValue1+fValue2);          case SUB:  return new Double(fValue1-fValue2);          case LT:   return new Integer((fValue1 < fValue2)?1:0);          case GT:   return new Integer((fValue1 > fValue2)?1:0);          case LE:   return new Integer((fValue1 <= fValue2)?1:0);          case GE:   return new Integer((fValue1 >= fValue2)?1:0);          /*           * REMARK: NE and EQ will be considered illegal operations here           * because of the statistical probability of meeting the condition.           */          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (oValue2 instanceof String) {        String sValue2 = (String)oValue2;        switch (m_kBINToken) {          case POW:  throw new XIllegalOperation(this,oValue1,oValue2);          case MUL:  throw new XIllegalOperation(this,oValue1,oValue2);          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,oValue1,oValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return Double.toString(fValue1) + sValue2;          case SUB:  throw new XIllegalOperation(this,oValue1,oValue2);          case LT:   throw new XIllegalOperation(this,oValue1,oValue2);          case GT:   throw new XIllegalOperation(this,oValue1,oValue2);          case LE:   throw new XIllegalOperation(this,oValue1,oValue2);          case GE:   throw new XIllegalOperation(this,oValue1,oValue2);          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else        throw new XIllegalStatus(getPosition());    }    else if (oValue1 instanceof String) {      String sValue1 = (String)oValue1;      if (oValue2 instanceof Integer) {        int dValue2 = ((Integer)oValue2).intValue();        switch (m_kBINToken) {          case POW:  throw new XIllegalOperation(this,oValue1,oValue2);          case MUL: {            String sValue = sValue1;            if (dValue2 <= 0) throw new XIllegalOperation(this,oValue1,oValue2);            for (int iCount = 1; iCount < dValue2; iCount++) {              sValue = sValue + sValue1;            }            return sValue;          }          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,oValue1,oValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return sValue1 + Integer.toString(dValue2);          case SUB:  throw new XIllegalOperation(this,oValue1,oValue2);          case LT:   throw new XIllegalOperation(this,oValue1,oValue2);          case GT:   throw new XIllegalOperation(this,oValue1,oValue2);          case LE:   throw new XIllegalOperation(this,oValue1,oValue2);          case GE:   throw new XIllegalOperation(this,oValue1,oValue2);          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (oValue2 instanceof Double) {        double fValue2 = ((Double)oValue2).doubleValue();        switch (m_kBINToken) {          case POW:  throw new XIllegalOperation(this,oValue1,oValue2);          case MUL:  throw new XIllegalOperation(this,oValue1,oValue2);          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,oValue1,oValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return sValue1 + Double.toString(fValue2);          case SUB:  throw new XIllegalOperation(this,oValue1,oValue2);          case LT:   throw new XIllegalOperation(this,oValue1,oValue2);          case GT:   throw new XIllegalOperation(this,oValue1,oValue2);          case LE:   throw new XIllegalOperation(this,oValue1,oValue2);          case GE:   throw new XIllegalOperation(this,oValue1,oValue2);          case NE:   throw new XIllegalOperation(this,oValue1,oValue2);          case EQ:   throw new XIllegalOperation(this,oValue1,oValue2);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (oValue2 instanceof String) {        String sValue2 = (String)oValue2;        switch (m_kBINToken) {          case POW:  throw new XIllegalOperation(this,oValue1,oValue2);          case MUL:  throw new XIllegalOperation(this,oValue1,oValue2);          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,oValue1,oValue2);          case MOD:  throw new XIllegalOperation(this,oValue1,oValue2);          case ADD:  return sValue1 + sValue2;          case SUB:  throw new XIllegalOperation(this,oValue1,oValue2);          case LT:   return new Integer(sValue1.compareTo(sValue2) < 0 ?1:0);          case GT:   return new Integer(sValue1.compareTo(sValue2) > 0 ?1:0);          case LE:   return new Integer(sValue1.compareTo(sValue2) <= 0 ?1:0);          case GE:   return new Integer(sValue1.compareTo(sValue2) >= 0 ?1:0);          case NE:   return new Integer(sValue1.equals(sValue2)?0:1);          case EQ:   return new Integer(sValue1.equals(sValue2)?1:0);          case AND:  throw new XIllegalOperation(this,oValue1,oValue2);          case XOR:  throw new XIllegalOperation(this,oValue1,oValue2);          case OR:   throw new XIllegalOperation(this,oValue1,oValue2);          case LAND: throw new XIllegalOperation(this,oValue1,oValue2);          case LOR:  throw new XIllegalOperation(this,oValue1,oValue2);          default:   throw new XIllegalStatus(getPosition());        }      }      else        throw new XIllegalStatus(getPosition());    }    else      throw new XIllegalStatus(getPosition());          /*     * The code should never reach here. However, the JDK currently does not allow     * to write unreachable code, so there is no way to throw an exception. Luckily     * in this case a return value is expected, so if by any uncaught state the code     * could be reached there will be a warning at compile time.     */    /* return null; */  }}