/* * JMEP - Java Mathematical Expression Parser. * Copyright (C) 1999  Jo Desmet *  * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or any later version. *  * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. *  * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA *  * You can contact the Original submitter of this library by * email at: Jo_Desmet@yahoo.com. *  */package com.iabcinc.jmep.tokens;import com.iabcinc.jmep.XExpression;import com.iabcinc.jmep.XIllegalOperation;import com.iabcinc.jmep.XIllegalStatus;public class BINToken extends Token {  public enum Operator {    POW  (9,false), /* Raise to a power */    MUL  (8,true ), /* Multiply */    DIV  (8,false), /* divide (non-strict: int/int=double) */    MOD  (8,false), /* Modulus for a division */    ADD  (7,true ), /* Add */    SUB  (7,false), /* Subtract */    LT   (6,false), /* Test for Less Than */    GT   (6,false), /* Test for More Than */    LE   (6,false), /* Test for Less or Equal */    GE   (6,false), /* Test for More or Equal */    NE   (6,true ), /* Test for non-Equality */    EQ   (6,true ), /* Test for Equality */    AND  (4,true ), /* Bitwise AND */    OR   (2,true ), /* Bitwise OR */    XOR  (3,true ), /* Bitwise XOR */    LAND (1,true ), /* Logical AND */    LOR  (0,true ), /* Logical OR */    SDIV (8,false); /* Strict division (int/int = int) */    public final int precedence;    public final boolean commutative;    public boolean isCommutative() {      return commutative;    }        Operator(int precedence,boolean commutative) {      this.precedence = precedence;      this.commutative = commutative;    }  }    private Operator operator;  //private int m_iPrecedence;  static int resolvePrecedence(Operator kBINToken) {    return kBINToken.precedence;  }  public BINToken(Operator kBINToken,int iPosition) {    super(Token.BIN,iPosition);    operator = kBINToken;    //m_iPrecedence = resolvePrecedence(kBINToken);  }    public int getPrecedence() {    return operator.precedence;  }  public Operator getKindOfBIN() {    return operator;  }    public Number evaluateDoubleDouble(double doubleValue1,double doubleValue2)   throws XExpression {      switch (operator) {      case POW:  return new Double(Math.pow(doubleValue1,doubleValue2));      case MUL:  return new Double(doubleValue1*doubleValue2);      case SDIV: /* continue with next */      case DIV:  return new Double(doubleValue1/doubleValue2);      case ADD:  return new Double(doubleValue1+doubleValue2);      case SUB:  return new Double(doubleValue1-doubleValue2);      case LT:   return new Integer((doubleValue1 < doubleValue2)?1:0);      case GT:   return new Integer((doubleValue1 > doubleValue2)?1:0);      case LE:   return new Integer((doubleValue1 <= doubleValue2)?1:0);      case GE:   return new Integer((doubleValue1 >= doubleValue2)?1:0);      case NE: case EQ: 	  case AND: case XOR: case OR: case LAND: case LOR:	  case MOD:    	  throw new XIllegalOperation(this);    }    throw new XIllegalStatus(getPosition());  }    public Number evaluateIntInt(int intValue1,int intValue2) throws XExpression {    switch (operator) {      case POW:    	if (intValue2 == 0) return 1;    	if (intValue2 >= 0 && intValue2 < 5) {    		int returnValue = 1;    		for (int i=0; i<intValue2; i++) returnValue *= intValue1;    		return new Integer(returnValue);    	}        return new Double(Math.pow(intValue1,intValue2));      case MUL:  return new Integer(intValue1*intValue2);      case SDIV: return new Integer(intValue1/intValue2);      case DIV:  return new Double((double)intValue1/intValue2);      case MOD:  return new Integer(intValue1%intValue2);      case ADD:  return new Integer(intValue1+intValue2);      case SUB:  return new Integer(intValue1-intValue2);      case LT:   return new Integer((intValue1 < intValue2)?1:0);      case GT:   return new Integer((intValue1 > intValue2)?1:0);      case LE:   return new Integer((intValue1 <= intValue2)?1:0);      case GE:   return new Integer((intValue1 >= intValue2)?1:0);      case NE:   return new Integer((intValue1 != intValue2)?1:0);      case EQ:   return new Integer((intValue1 == intValue2)?1:0);      case AND:  return new Integer(intValue1&intValue2);      case XOR:  return new Integer(intValue1^intValue2);      case OR:   return new Integer(intValue1|intValue2);      case LAND: return new Integer(((intValue1 != 0) && (intValue2 != 0))?1:0);      case LOR:  return new Integer(((intValue1 != 0) || (intValue2 != 0))?1:0);    }    throw new XIllegalStatus(getPosition());	    }    public Object evaluateStringString(String sValue1,String sValue2) throws XExpression {    switch (operator) {      case ADD:  return sValue1 + sValue2;      case LT:   return new Integer(sValue1.compareTo(sValue2) < 0 ?1:0);      case GT:   return new Integer(sValue1.compareTo(sValue2) > 0 ?1:0);      case LE:   return new Integer(sValue1.compareTo(sValue2) <= 0 ?1:0);      case GE:   return new Integer(sValue1.compareTo(sValue2) >= 0 ?1:0);      case NE:   return new Integer(sValue1.equals(sValue2)?0:1);      case EQ:   return new Integer(sValue1.equals(sValue2)?1:0);      case POW: case MUL: case SDIV: case DIV: case MOD:      case SUB: case AND: case XOR: case OR: case LAND: case LOR:    	  throw new XIllegalOperation(this);    }    throw new XIllegalStatus(getPosition());	  }    public Object evaluate(Object leftOperand, Object rightOperand)  throws XExpression {    if (leftOperand instanceof Integer) {      int intValue1 = ((Integer)leftOperand).intValue();      if (rightOperand instanceof Integer) {        int intValue2 = ((Integer)rightOperand).intValue();        return evaluateIntInt(intValue1,intValue2);      } else if (rightOperand instanceof Double) {        double doubleValue2 = ((Double)rightOperand).doubleValue();        return evaluateDoubleDouble((double)intValue1,doubleValue2);      } else if (rightOperand instanceof String) {        String sValue2 = (String)rightOperand;        switch (operator) {          case POW:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MUL: {            String sValue = sValue2;            if (intValue1 <= 0) throw new XIllegalOperation(this,leftOperand,rightOperand);            for (int iCount = 1; iCount < intValue1; iCount++) {              sValue = sValue + sValue2;            }            return sValue;          }          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MOD:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case ADD:  return Integer.toString(intValue1) + sValue2;          case SUB:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case LT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case NE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case EQ:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case AND:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case XOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case OR:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LAND: throw new XIllegalOperation(this,leftOperand,rightOperand);          case LOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          default:   throw new XIllegalStatus(getPosition());        }      }      else        throw new XIllegalStatus(getPosition());    }    else if (leftOperand instanceof Double) {      double doubleValue1 = ((Double)leftOperand).doubleValue();      if (rightOperand instanceof Integer) {        int intValue2 = ((Integer)rightOperand).intValue();        return evaluateDoubleDouble(doubleValue1,(double)intValue2);      }      else if (rightOperand instanceof Double) {        double doubleValue2 = ((Double)rightOperand).doubleValue();    	return evaluateDoubleDouble(doubleValue1, doubleValue2);      }      else if (rightOperand instanceof String) {        String sValue2 = (String)rightOperand;        switch (operator) {          case POW:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MUL:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MOD:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case ADD:  return Double.toString(doubleValue1) + sValue2;          case SUB:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case LT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case NE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case EQ:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case AND:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case XOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case OR:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LAND: throw new XIllegalOperation(this,leftOperand,rightOperand);          case LOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          default:   throw new XIllegalStatus(getPosition());        }      }      else        throw new XIllegalStatus(getPosition());    }    else if (leftOperand instanceof String) {      String sValue1 = (String)leftOperand;      if (rightOperand instanceof Integer) {        int dValue2 = ((Integer)rightOperand).intValue();        switch (operator) {          case POW:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MUL: {            String sValue = sValue1;            if (dValue2 <= 0) throw new XIllegalOperation(this,leftOperand,rightOperand);            for (int iCount = 1; iCount < dValue2; iCount++) {              sValue = sValue + sValue1;            }            return sValue;          }          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MOD:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case ADD:  return sValue1 + Integer.toString(dValue2);          case SUB:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case LT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case NE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case EQ:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case AND:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case XOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case OR:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LAND: throw new XIllegalOperation(this,leftOperand,rightOperand);          case LOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (rightOperand instanceof Double) {        double fValue2 = ((Double)rightOperand).doubleValue();        switch (operator) {          case POW:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MUL:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case SDIV: /* continue with next */          case DIV:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case MOD:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case ADD:  return sValue1 + Double.toString(fValue2);          case SUB:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case LT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GT:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case GE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case NE:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case EQ:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case AND:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case XOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          case OR:   throw new XIllegalOperation(this,leftOperand,rightOperand);          case LAND: throw new XIllegalOperation(this,leftOperand,rightOperand);          case LOR:  throw new XIllegalOperation(this,leftOperand,rightOperand);          default:   throw new XIllegalStatus(getPosition());        }      }      else if (rightOperand instanceof String) {        String sValue2 = (String)rightOperand;        return evaluateStringString(sValue1,sValue2);      }      else        throw new XIllegalStatus(getPosition());    }    else      throw new XIllegalStatus(getPosition());          /*     * The code should never reach here. However, the JDK currently does not allow     * to write unreachable code, so there is no way to throw an exception. Luckily     * in this case a return value is expected, so if by any uncaught state the code     * could be reached there will be a warning at compile time.     */    /* return null; */  }}